<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `csv` crate."><meta name="keywords" content="rust, rustlang, rust-lang, csv"><title>csv - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../csv/index.html'><img src='../rust-logo.png' alt='logo' width='100'></a><p class='location'>Crate csv</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all csv's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'csv', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/csv/lib.rs.html#1-325' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>csv</a></span></h1><div class='docblock'><p>This crate provides a streaming CSV (comma separated values) writer and
reader that works with the <code>serialize</code> crate to do type based encoding
and decoding. There are two primary goals of this project:</p>
<ol>
<li>The default mode of parsing should <em>just work</em>. This means the parser
will bias toward providing <em>a</em> parse over a <em>correct</em> parse (with
respect to RFC 4180).</li>
<li>Convenient to use by default, but when performance is needed, the
API will provide an escape hatch.</li>
</ol>
<h2 id="simple-example" class="section-header"><a href="#simple-example">Simple example</a></h2>
<p>This shows how you can decode records into Rust types. This saves a ton
of boiler plate, e.g., converting strings to numeric types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv</span>::<span class="ident">Reader</span>::<span class="ident">from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">decode</span>() {
    <span class="kw">let</span> (<span class="ident">n1</span>, <span class="ident">n2</span>, <span class="ident">dist</span>): (<span class="ident">String</span>, <span class="ident">String</span>, <span class="ident">u32</span>) <span class="op">=</span> <span class="ident">row</span>.<span class="ident">unwrap</span>();
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}, {}: {}&quot;</span>, <span class="ident">n1</span>, <span class="ident">n2</span>, <span class="ident">dist</span>);
}</pre></div>
<p>If you just want a <code>Vec</code> of all the records, then you can use the
<code>collect</code> method defined on iterators:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">type</span> <span class="ident">Row</span> <span class="op">=</span> (<span class="ident">String</span>, <span class="ident">String</span>, <span class="ident">u32</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv</span>::<span class="ident">Reader</span>::<span class="ident">from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">let</span> <span class="ident">rows</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">decode</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">csv</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Row</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rows</span>.<span class="ident">len</span>(), <span class="number">5</span>);</pre></div>
<p>Please see the <code>Reader</code> type for more documentation and examples.</p>
<h2 id="iteratoring-over-records" class="section-header"><a href="#iteratoring-over-records">Iteratoring over records</a></h2>
<p>This crate exposes <strong>4</strong> distinct ways of iterating over CSV records. In
the majority of use cases, you should use the <code>decode</code> method as shown
above because it is the most convenient. But other types of iterators are
exposed for when you need them.</p>
<p>The iterators listed below are presented in order of performance. The first
(type based decoding) is the slowest and the last (zero allocation) is the
fastest. There is clear evidence of this claim in the benchmarks. (Just
run <code>cargo bench</code>.)</p>
<h3 id="decoded-records" class="section-header"><a href="#decoded-records">Decoded records</a></h3>
<p>As shown above. This uses type based decoding on each record.</p>
<h3 id="string-records" class="section-header"><a href="#string-records">String records</a></h3>
<p>Yields each record as a <code>Vec&lt;String&gt;</code>. Namely, this assumes that all CSV
data is UTF-8 encoded. This is the standard CSV interface that you've
probably come to expect from using other CSV parsers.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv</span>::<span class="ident">Reader</span>::<span class="ident">from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">r</span><span class="op">|</span> <span class="ident">r</span>.<span class="ident">unwrap</span>()) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">row</span>);
}</pre></div>
<h3 id="byte-string-records" class="section-header"><a href="#byte-string-records">Byte string records</a></h3>
<p>Yields each record as a <code>Vec&lt;ByteString&gt;</code>. Namely, this allows reading CSV
data that is not UTF-8 encoded (or improperly encoded!).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">b&quot;
sti\xffcker,mortals,7
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv</span>::<span class="ident">Reader</span>::<span class="ident">from_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[..]).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">r</span><span class="op">|</span> <span class="ident">r</span>.<span class="ident">unwrap</span>()) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">row</span>);
}</pre></div>
<h3 id="byte-slice-records" class="section-header"><a href="#byte-slice-records">Byte slice records</a></h3>
<p>This iterator is defined on the <code>Reader</code> type itself and yields <em>fields</em>
instead of records (unlike the other iterators). Each field is a <code>&amp;[u8]</code>.
No allocation is performed during parsing (unlike the other iterators,
which at least allocate a <code>Vec&lt;u8&gt;</code> for each field and a <code>Vec&lt;_&gt;</code> for each
record). Since no allocation is performed, this &quot;iterator&quot; doesn't actually
implement the <code>Iterator</code> trait (since it cannot be done safely).</p>
<p>This is the lowest level interface and should only be used when you need
the performance.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv</span>::<span class="ident">Reader</span>::<span class="ident">from_string</span>(<span class="ident">data</span>);
<span class="kw">while</span> <span class="op">!</span><span class="ident">rdr</span>.<span class="ident">done</span>() {
    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">r</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">next_bytes</span>().<span class="ident">into_iter_result</span>() {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{:?} &quot;</span>, <span class="ident">r</span>.<span class="ident">unwrap</span>());
    }
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;&quot;</span>);
}</pre></div>
<p>There is more explanation for how this iterator interface works on the
<code>Reader</code> type.</p>
<h2 id="indexing" class="section-header"><a href="#indexing">Indexing</a></h2>
<p>This crate has experimental support for CSV record indexing. It's very
simplistic, but once the index is created, you can seek a <code>csv::Reader</code>
to any record instantly. See the
<a href="/rustdoc/csv/index/index.html"><code>csv::index</code></a>
sub-module for more details and examples.</p>
<h2 id="compliance-with-rfc-4180" class="section-header"><a href="#compliance-with-rfc-4180">Compliance with RFC 4180</a></h2>
<p><a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a> seems to the closest thing
to an official specification for CSV. Currently, the parser in this crate
will read a strict superset of RFC 4180 while the writer will always write
CSV data that conforms to RFC 4180 (unless configured to do otherwise).
This approach was taken because CSV data is commonly malformed and there is
nothing worse than trying to read busted CSV data with a library that says
it can't do it.</p>
<p>With that said, a &quot;strict&quot; mode may be added that will only read CSV data
that conforms to RFC 4180.</p>
<p>Here are a few notes on compatibility with RFC 4180:</p>
<ul>
<li>Both CRLF and LF line endings are supported. This is seamless in the
parser. By default, the encoder uses LF line endings but can be
instructed to use CRLF with the <code>crlf</code> method.</li>
<li>The first record is read as a &quot;header&quot; by default, but this can be
disabled by calling <code>has_headers(false)</code> before reading any records.
(N.B. The encoder has no explicit support for headers. Simply encode a
vector of strings instead.)</li>
<li>By default, the delimiter is a comma, but it can be changed to any
<strong>ASCII</strong> byte character with the <code>delimiter</code> method (for either
writing or reading).</li>
<li>By default, both the writer and reader will enforce the invariant
that all records are the same length. (This is what RFC 4180 demands.)
If a record with a different length is found, an error is returned.
This behavior may be turned off by calling <code>flexible</code> with <code>true</code>.</li>
<li>Empty lines (that do not include other whitespace) are ignored
by the parser.</li>
<li>This crates parses CSV data at the <em>byte</em> level, which means all
delimiter and quote characters must be ASCII. While unfortunate, this
means that CSV data that is not UTF-8 encoded can be parsed. In
general, the writer and reader API biases toward using Unicode strings
while providing an outlet to use byte strings.</li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="index/index.html" title='csv::index mod'>index</a></td><td class='docblock-short'><p>This sub-module provides experimental CSV record indexing.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.ByteRecords.html" title='csv::ByteRecords struct'>ByteRecords</a></td><td class='docblock-short'><p>An iterator of <code>ByteString</code> records.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Decoded.html" title='csv::Decoded struct'>Decoded</a></td><td class='docblock-short'><p>A record to be decoded.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DecodedRecords.html" title='csv::DecodedRecords struct'>DecodedRecords</a></td><td class='docblock-short'><p>An iterator of decoded records.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Encoded.html" title='csv::Encoded struct'>Encoded</a></td><td class='docblock-short'><p>A record to be encoded.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.LocatableError.html" title='csv::LocatableError struct'>LocatableError</a></td><td class='docblock-short'><p>An error tagged with a location at which it occurred.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Reader.html" title='csv::Reader struct'>Reader</a></td><td class='docblock-short'><p>A CSV reader.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StringRecords.html" title='csv::StringRecords struct'>StringRecords</a></td><td class='docblock-short'><p>An iterator of <code>String</code> records.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Writer.html" title='csv::Writer struct'>Writer</a></td><td class='docblock-short'><p>A CSV writer.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Error.html" title='csv::Error enum'>Error</a></td><td class='docblock-short'><p>An error produced by an operation on CSV data.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.NextField.html" title='csv::NextField enum'>NextField</a></td><td class='docblock-short'><p>NextField is the result of parsing a single CSV field.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ParseError.html" title='csv::ParseError enum'>ParseError</a></td><td class='docblock-short'><p>A description of a CSV parse error.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.QuoteStyle.html" title='csv::QuoteStyle enum'>QuoteStyle</a></td><td class='docblock-short'><p>The quoting style to use when writing CSV data.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.RecordTerminator.html" title='csv::RecordTerminator enum'>RecordTerminator</a></td><td class='docblock-short'><p>A record terminator.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.BorrowBytes.html" title='csv::BorrowBytes trait'>BorrowBytes</a></td><td class='docblock-short'><p>A trait that permits borrowing byte vectors.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.ByteString.html" title='csv::ByteString type'>ByteString</a></td><td class='docblock-short'><p>A convenience type for referring to a plain byte string.</p>
</td></tr><tr class='module-item'><td><a class="type" href="type.Result.html" title='csv::Result type'>Result</a></td><td class='docblock-short'><p>A convenience type for representing the result of most CSV reader/writer
operations.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "csv";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>